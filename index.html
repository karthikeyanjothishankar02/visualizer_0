<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Space+Mono:wght@400;700&family=Playfair+Display:wght@900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e27;
            --bg-secondary: #151932;
            --bg-card: #1a1f3a;
            --accent-primary: #00d4ff;
            --accent-secondary: #ff006e;
            --accent-tertiary: #ffbe0b;
            --accent-success: #06ffa5;
            --text-primary: #e8edf5;
            --text-secondary: #8892b0;
            --bar-default: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bar-comparing: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --bar-swapping: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --bar-sorted: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            --bar-pivot: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --shadow-glow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(102, 126, 234, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 0, 110, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(0, 212, 255, 0.08) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 40px 20px;
            position: relative;
            z-index: 1;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
            align-items: start;
        }

        header {
            text-align: center;
            margin-bottom: 50px;
            animation: fadeInDown 0.8s ease-out;
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            letter-spacing: -2px;
            text-shadow: 0 0 40px rgba(0, 212, 255, 0.3);
        }

        .subtitle {
            font-family: 'Space Mono', monospace;
            color: var(--text-secondary);
            font-size: 1.1rem;
            letter-spacing: 2px;
        }

        .controls {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3), var(--shadow-glow);
            border: 1px solid rgba(0, 212, 255, 0.1);
            animation: fadeInUp 0.8s ease-out 0.2s both;
            position: sticky;
            top: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 25px;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent-primary);
            font-weight: 700;
        }

        select, input[type="range"] {
            background: var(--bg-secondary);
            border: 2px solid rgba(0, 212, 255, 0.2);
            color: var(--text-primary);
            padding: 12px 15px;
            border-radius: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        select:hover, select:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.2);
            outline: none;
        }

        input[type="range"] {
            padding: 0;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.8);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .value-display {
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-align: right;
        }

        .button-group {
            display: flex;
            gap: 12px;
            flex-direction: column;
        }

        button {
            background: linear-gradient(135deg, var(--accent-primary), #0099cc);
            color: var(--bg-primary);
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            width: 100%;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 212, 255, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        button:disabled:hover {
            box-shadow: none;
        }

        button.secondary {
            background: linear-gradient(135deg, var(--accent-secondary), #cc0055);
        }

        button.success {
            background: linear-gradient(135deg, var(--accent-success), #05cc7a);
        }

        .stats {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 0, 110, 0.1);
            animation: fadeInUp 0.8s ease-out 0.4s both;
        }

        .right-column {
            display: flex;
            flex-direction: column;
        }

        .stat-item {
            text-align: center;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid rgba(0, 212, 255, 0.1);
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.2);
        }

        .stat-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-primary);
            font-family: 'Space Mono', monospace;
        }

        .visualization {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            min-height: 500px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 190, 11, 0.1);
            position: relative;
            overflow: hidden;
            animation: fadeInUp 0.8s ease-out 0.6s both;
        }

        .visualization::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
        }

        .bars-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 400px;
            gap: 2px;
            padding: 20px 0;
        }

        .bar {
            flex: 1;
            max-width: 60px;
            background: var(--bar-default);
            border-radius: 4px 4px 0 0;
            position: relative;
            transition: all 0.3s ease;
            box-shadow: 0 -2px 10px rgba(102, 126, 234, 0.3);
        }

        .bar::after {
            content: attr(data-value);
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 700;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .bar:hover::after {
            opacity: 1;
        }

        .bar.comparing {
            background: var(--bar-comparing);
            box-shadow: 0 -2px 20px rgba(245, 87, 108, 0.5);
            transform: scale(1.05);
        }

        .bar.swapping {
            background: var(--bar-swapping);
            box-shadow: 0 -2px 20px rgba(0, 242, 254, 0.5);
            transform: scale(1.1) translateY(-5px);
        }

        .bar.sorted {
            background: var(--bar-sorted);
            box-shadow: 0 -2px 20px rgba(56, 249, 215, 0.5);
        }

        .bar.pivot {
            background: var(--bar-pivot);
            box-shadow: 0 -2px 20px rgba(254, 225, 64, 0.6);
            transform: scale(1.08);
        }

        .algorithm-info {
            margin-top: 30px;
            padding: 25px;
            background: var(--bg-secondary);
            border-radius: 15px;
            border-left: 4px solid var(--accent-primary);
        }

        .algorithm-info h3 {
            color: var(--accent-primary);
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .complexity-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .complexity-item {
            background: var(--bg-card);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(0, 212, 255, 0.1);
        }

        .complexity-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .complexity-value {
            font-size: 1.1rem;
            color: var(--accent-tertiary);
            font-weight: 700;
            font-family: 'Space Mono', monospace;
        }

        .description {
            color: var(--text-secondary);
            line-height: 1.7;
            margin-top: 15px;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .sorting-active .bar:not(.comparing):not(.swapping):not(.pivot) {
            animation: pulse 2s ease-in-out infinite;
        }

        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .controls {
                position: relative;
                top: 0;
            }

            h1 {
                font-size: 2.5rem;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }

            .stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Sort Spectrum</h1>
            <p class="subtitle">Algorithmic Beauty in Motion</p>
        </header>

        <div class="main-layout">
            <div class="controls">
                <div class="control-group">
                    <div class="control-item">
                        <label for="algorithm">Algorithm</label>
                        <select id="algorithm">
                            <option value="bubble">Bubble Sort</option>
                            <option value="insertion">Insertion Sort</option>
                            <option value="selection">Selection Sort</option>
                            <option value="quick">Quick Sort</option>
                            <option value="merge">Merge Sort</option>
                            <option value="heap">Heap Sort</option>
                            <option value="counting">Counting Sort</option>
                            <option value="radix">Radix Sort</option>
                            <option value="bucket">Bucket Sort</option>
                            <option value="tim">Tim Sort</option>
                        </select>
                    </div>

                    <div class="control-item">
                        <label for="arraySize">Array Size: <span class="value-display" id="arraySizeValue">50</span></label>
                        <input type="range" id="arraySize" min="10" max="100" value="50">
                    </div>

                    <div class="control-item">
                        <label for="speed">Speed: <span class="value-display" id="speedValue">50ms</span></label>
                        <input type="range" id="speed" min="10" max="500" value="50">
                    </div>
                </div>

                <div class="button-group">
                    <button id="startBtn">Start Sorting</button>
                    <button id="pauseBtn" class="secondary" disabled>Pause</button>
                    <button id="resetBtn" class="secondary">Generate New Array</button>
                    <button id="stepBtn" class="success" disabled>Step Through</button>
                </div>
            </div>

            <div class="right-column">
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Comparisons</div>
                        <div class="stat-value" id="comparisons">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Array Accesses</div>
                        <div class="stat-value" id="accesses">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Swaps</div>
                        <div class="stat-value" id="swaps">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Time Elapsed</div>
                        <div class="stat-value" id="timeElapsed">0ms</div>
                    </div>
                </div>

                <div class="visualization">
                    <div class="bars-container" id="barsContainer"></div>
                    <div class="algorithm-info" id="algorithmInfo"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class SortingVisualizer {
            constructor() {
                this.array = [];
                this.arraySize = 50;
                this.speed = 50;
                this.comparisons = 0;
                this.accesses = 0;
                this.swaps = 0;
                this.isSorting = false;
                this.isPaused = false;
                this.shouldStop = false;
                this.stepMode = false;
                this.startTime = 0;
                this.timeInterval = null;

                this.initializeElements();
                this.attachEventListeners();
                this.generateArray();
                this.updateAlgorithmInfo();
            }

            initializeElements() {
                this.barsContainer = document.getElementById('barsContainer');
                this.algorithmSelect = document.getElementById('algorithm');
                this.arraySizeInput = document.getElementById('arraySize');
                this.speedInput = document.getElementById('speed');
                this.startBtn = document.getElementById('startBtn');
                this.pauseBtn = document.getElementById('pauseBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.stepBtn = document.getElementById('stepBtn');
                this.comparisonsEl = document.getElementById('comparisons');
                this.accessesEl = document.getElementById('accesses');
                this.swapsEl = document.getElementById('swaps');
                this.timeElapsedEl = document.getElementById('timeElapsed');
            }

            attachEventListeners() {
                this.algorithmSelect.addEventListener('change', () => this.updateAlgorithmInfo());
                this.arraySizeInput.addEventListener('input', (e) => {
                    this.arraySize = parseInt(e.target.value);
                    document.getElementById('arraySizeValue').textContent = this.arraySize;
                    if (!this.isSorting) this.generateArray();
                });
                this.speedInput.addEventListener('input', (e) => {
                    this.speed = parseInt(e.target.value);
                    document.getElementById('speedValue').textContent = `${this.speed}ms`;
                });
                this.startBtn.addEventListener('click', () => this.startSorting());
                this.pauseBtn.addEventListener('click', () => this.togglePause());
                this.resetBtn.addEventListener('click', () => this.reset());
                this.stepBtn.addEventListener('click', () => this.enableStepMode());
            }

            generateArray() {
                this.array = Array.from({ length: this.arraySize }, () => 
                    Math.floor(Math.random() * 380) + 20
                );
                this.renderBars();
                this.resetStats();
            }

            renderBars() {
                this.barsContainer.innerHTML = '';
                const maxHeight = 400;
                const maxValue = Math.max(...this.array);

                this.array.forEach((value, index) => {
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    bar.style.height = `${(value / maxValue) * maxHeight}px`;
                    bar.setAttribute('data-value', value);
                    bar.setAttribute('data-index', index);
                    this.barsContainer.appendChild(bar);
                });
            }

            async updateBar(index, value, className = '') {
                const bars = this.barsContainer.children;
                if (bars[index]) {
                    const maxValue = Math.max(...this.array);
                    bars[index].style.height = `${(value / maxValue) * 400}px`;
                    bars[index].setAttribute('data-value', value);
                    bars[index].className = `bar ${className}`;
                }
            }

            async highlightBars(indices, className) {
                const bars = this.barsContainer.children;
                indices.forEach(index => {
                    if (bars[index]) {
                        bars[index].classList.add(className);
                    }
                });
            }

            async unhighlightBars(indices) {
                const bars = this.barsContainer.children;
                indices.forEach(index => {
                    if (bars[index]) {
                        bars[index].className = 'bar';
                    }
                });
            }

            async sleep() {
                if (this.stepMode) {
                    return new Promise(resolve => {
                        this.stepResolve = resolve;
                    });
                }

                while (this.isPaused && !this.shouldStop) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                if (this.shouldStop) throw new Error('Sorting stopped');

                return new Promise(resolve => setTimeout(resolve, this.speed));
            }

            async startSorting() {
                if (this.isSorting) return;

                this.isSorting = true;
                this.shouldStop = false;
                this.resetStats();
                this.startBtn.disabled = true;
                this.pauseBtn.disabled = false;
                this.stepBtn.disabled = false;
                this.resetBtn.disabled = true;
                this.barsContainer.classList.add('sorting-active');

                this.startTime = Date.now();
                this.timeInterval = setInterval(() => {
                    this.timeElapsedEl.textContent = `${Date.now() - this.startTime}ms`;
                }, 10);

                try {
                    const algorithm = this.algorithmSelect.value;
                    switch (algorithm) {
                        case 'bubble': await this.bubbleSort(); break;
                        case 'insertion': await this.insertionSort(); break;
                        case 'selection': await this.selectionSort(); break;
                        case 'quick': await this.quickSort(0, this.array.length - 1); break;
                        case 'merge': await this.mergeSort(0, this.array.length - 1); break;
                        case 'heap': await this.heapSort(); break;
                        case 'counting': await this.countingSort(); break;
                        case 'radix': await this.radixSort(); break;
                        case 'bucket': await this.bucketSort(); break;
                        case 'tim': await this.timSort(); break;
                    }

                    await this.markAllSorted();
                } catch (error) {
                    if (error.message !== 'Sorting stopped') {
                        console.error(error);
                    }
                } finally {
                    this.finishSorting();
                }
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                this.pauseBtn.textContent = this.isPaused ? 'Resume' : 'Pause';
            }

            enableStepMode() {
                this.stepMode = true;
                this.isPaused = false;
                this.pauseBtn.textContent = 'Pause';
                if (this.stepResolve) {
                    this.stepResolve();
                }
            }

            reset() {
                this.shouldStop = true;
                this.isSorting = false;
                this.isPaused = false;
                this.stepMode = false;
                clearInterval(this.timeInterval);
                this.generateArray();
                this.startBtn.disabled = false;
                this.pauseBtn.disabled = true;
                this.stepBtn.disabled = true;
                this.resetBtn.disabled = false;
                this.pauseBtn.textContent = 'Pause';
                this.barsContainer.classList.remove('sorting-active');
            }

            finishSorting() {
                this.isSorting = false;
                this.isPaused = false;
                this.stepMode = false;
                clearInterval(this.timeInterval);
                this.startBtn.disabled = false;
                this.pauseBtn.disabled = true;
                this.stepBtn.disabled = true;
                this.resetBtn.disabled = false;
                this.barsContainer.classList.remove('sorting-active');
            }

            resetStats() {
                this.comparisons = 0;
                this.accesses = 0;
                this.swaps = 0;
                this.updateStats();
            }

            updateStats() {
                this.comparisonsEl.textContent = this.comparisons;
                this.accessesEl.textContent = this.accesses;
                this.swapsEl.textContent = this.swaps;
            }

            async markAllSorted() {
                for (let i = 0; i < this.array.length; i++) {
                    await this.updateBar(i, this.array[i], 'sorted');
                    await this.sleep();
                }
            }

            // BUBBLE SORT
            async bubbleSort() {
                const n = this.array.length;
                for (let i = 0; i < n - 1; i++) {
                    let swapped = false;
                    for (let j = 0; j < n - i - 1; j++) {
                        this.comparisons++;
                        this.accesses += 2;
                        this.updateStats();

                        await this.highlightBars([j, j + 1], 'comparing');
                        await this.sleep();

                        if (this.array[j] > this.array[j + 1]) {
                            await this.highlightBars([j, j + 1], 'swapping');
                            [this.array[j], this.array[j + 1]] = [this.array[j + 1], this.array[j]];
                            this.swaps++;
                            this.updateStats();

                            await this.updateBar(j, this.array[j]);
                            await this.updateBar(j + 1, this.array[j + 1]);
                            await this.sleep();
                            swapped = true;
                        }

                        await this.unhighlightBars([j, j + 1]);
                    }
                    await this.updateBar(n - i - 1, this.array[n - i - 1], 'sorted');
                    if (!swapped) break;
                }
            }

            // INSERTION SORT
            async insertionSort() {
                const n = this.array.length;
                for (let i = 1; i < n; i++) {
                    const key = this.array[i];
                    let j = i - 1;

                    await this.highlightBars([i], 'pivot');
                    await this.sleep();

                    while (j >= 0) {
                        this.comparisons++;
                        this.accesses++;
                        this.updateStats();

                        await this.highlightBars([j], 'comparing');
                        await this.sleep();

                        if (this.array[j] <= key) {
                            await this.unhighlightBars([j]);
                            break;
                        }

                        await this.highlightBars([j], 'swapping');
                        this.array[j + 1] = this.array[j];
                        this.swaps++;
                        this.updateStats();

                        await this.updateBar(j + 1, this.array[j + 1]);
                        await this.sleep();
                        await this.unhighlightBars([j]);
                        j--;
                    }

                    this.array[j + 1] = key;
                    await this.updateBar(j + 1, key);
                    await this.unhighlightBars([i]);
                    await this.sleep();
                }
            }

            // SELECTION SORT
            async selectionSort() {
                const n = this.array.length;
                for (let i = 0; i < n - 1; i++) {
                    let minIdx = i;
                    await this.highlightBars([minIdx], 'pivot');

                    for (let j = i + 1; j < n; j++) {
                        this.comparisons++;
                        this.accesses += 2;
                        this.updateStats();

                        await this.highlightBars([j], 'comparing');
                        await this.sleep();

                        if (this.array[j] < this.array[minIdx]) {
                            await this.unhighlightBars([minIdx]);
                            minIdx = j;
                            await this.highlightBars([minIdx], 'pivot');
                        }

                        await this.unhighlightBars([j]);
                    }

                    if (minIdx !== i) {
                        await this.highlightBars([i, minIdx], 'swapping');
                        [this.array[i], this.array[minIdx]] = [this.array[minIdx], this.array[i]];
                        this.swaps++;
                        this.updateStats();

                        await this.updateBar(i, this.array[i]);
                        await this.updateBar(minIdx, this.array[minIdx]);
                        await this.sleep();
                    }

                    await this.unhighlightBars([i, minIdx]);
                    await this.updateBar(i, this.array[i], 'sorted');
                }
                await this.updateBar(n - 1, this.array[n - 1], 'sorted');
            }

            // QUICK SORT
            async quickSort(low, high) {
                if (low < high) {
                    const pi = await this.partition(low, high);
                    await this.quickSort(low, pi - 1);
                    await this.quickSort(pi + 1, high);
                }
            }

            async partition(low, high) {
                const pivot = this.array[high];
                await this.highlightBars([high], 'pivot');
                let i = low - 1;

                for (let j = low; j < high; j++) {
                    this.comparisons++;
                    this.accesses += 2;
                    this.updateStats();

                    await this.highlightBars([j], 'comparing');
                    await this.sleep();

                    if (this.array[j] < pivot) {
                        i++;
                        if (i !== j) {
                            await this.highlightBars([i, j], 'swapping');
                            [this.array[i], this.array[j]] = [this.array[j], this.array[i]];
                            this.swaps++;
                            this.updateStats();

                            await this.updateBar(i, this.array[i]);
                            await this.updateBar(j, this.array[j]);
                            await this.sleep();
                            await this.unhighlightBars([i]);
                        }
                    }

                    await this.unhighlightBars([j]);
                }

                await this.highlightBars([i + 1, high], 'swapping');
                [this.array[i + 1], this.array[high]] = [this.array[high], this.array[i + 1]];
                this.swaps++;
                this.updateStats();

                await this.updateBar(i + 1, this.array[i + 1]);
                await this.updateBar(high, this.array[high]);
                await this.sleep();
                await this.unhighlightBars([i + 1, high]);

                return i + 1;
            }

            // MERGE SORT
            async mergeSort(left, right) {
                if (left < right) {
                    const mid = Math.floor((left + right) / 2);
                    await this.mergeSort(left, mid);
                    await this.mergeSort(mid + 1, right);
                    await this.merge(left, mid, right);
                }
            }

            async merge(left, mid, right) {
                const leftArr = this.array.slice(left, mid + 1);
                const rightArr = this.array.slice(mid + 1, right + 1);

                let i = 0, j = 0, k = left;

                while (i < leftArr.length && j < rightArr.length) {
                    this.comparisons++;
                    this.accesses += 2;
                    this.updateStats();

                    await this.highlightBars([k], 'comparing');

                    if (leftArr[i] <= rightArr[j]) {
                        this.array[k] = leftArr[i];
                        await this.updateBar(k, leftArr[i]);
                        i++;
                    } else {
                        this.array[k] = rightArr[j];
                        await this.updateBar(k, rightArr[j]);
                        j++;
                    }

                    await this.sleep();
                    await this.unhighlightBars([k]);
                    k++;
                }

                while (i < leftArr.length) {
                    this.array[k] = leftArr[i];
                    await this.updateBar(k, leftArr[i]);
                    await this.sleep();
                    i++;
                    k++;
                }

                while (j < rightArr.length) {
                    this.array[k] = rightArr[j];
                    await this.updateBar(k, rightArr[j]);
                    await this.sleep();
                    j++;
                    k++;
                }
            }

            // HEAP SORT
            async heapSort() {
                const n = this.array.length;

                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    await this.heapify(n, i);
                }

                for (let i = n - 1; i > 0; i--) {
                    await this.highlightBars([0, i], 'swapping');
                    [this.array[0], this.array[i]] = [this.array[i], this.array[0]];
                    this.swaps++;
                    this.updateStats();

                    await this.updateBar(0, this.array[0]);
                    await this.updateBar(i, this.array[i]);
                    await this.sleep();
                    await this.unhighlightBars([0, i]);
                    await this.updateBar(i, this.array[i], 'sorted');

                    await this.heapify(i, 0);
                }
                await this.updateBar(0, this.array[0], 'sorted');
            }

            async heapify(n, i) {
                let largest = i;
                const left = 2 * i + 1;
                const right = 2 * i + 2;

                if (left < n) {
                    this.comparisons++;
                    this.accesses += 2;
                    this.updateStats();
                    if (this.array[left] > this.array[largest]) {
                        largest = left;
                    }
                }

                if (right < n) {
                    this.comparisons++;
                    this.accesses += 2;
                    this.updateStats();
                    if (this.array[right] > this.array[largest]) {
                        largest = right;
                    }
                }

                if (largest !== i) {
                    await this.highlightBars([i, largest], 'swapping');
                    [this.array[i], this.array[largest]] = [this.array[largest], this.array[i]];
                    this.swaps++;
                    this.updateStats();

                    await this.updateBar(i, this.array[i]);
                    await this.updateBar(largest, this.array[largest]);
                    await this.sleep();
                    await this.unhighlightBars([i, largest]);

                    await this.heapify(n, largest);
                }
            }

            // COUNTING SORT
            async countingSort() {
                const max = Math.max(...this.array);
                const min = Math.min(...this.array);
                const range = max - min + 1;
                const count = new Array(range).fill(0);
                const output = new Array(this.array.length);

                for (let i = 0; i < this.array.length; i++) {
                    await this.highlightBars([i], 'comparing');
                    count[this.array[i] - min]++;
                    this.accesses++;
                    this.updateStats();
                    await this.sleep();
                    await this.unhighlightBars([i]);
                }

                for (let i = 1; i < count.length; i++) {
                    count[i] += count[i - 1];
                }

                for (let i = this.array.length - 1; i >= 0; i--) {
                    await this.highlightBars([i], 'swapping');
                    output[count[this.array[i] - min] - 1] = this.array[i];
                    count[this.array[i] - min]--;
                    await this.sleep();
                    await this.unhighlightBars([i]);
                }

                for (let i = 0; i < this.array.length; i++) {
                    this.array[i] = output[i];
                    await this.updateBar(i, this.array[i]);
                    await this.sleep();
                }
            }

            // RADIX SORT
            async radixSort() {
                const max = Math.max(...this.array);
                let exp = 1;

                while (Math.floor(max / exp) > 0) {
                    await this.countingSortByDigit(exp);
                    exp *= 10;
                }
            }

            async countingSortByDigit(exp) {
                const n = this.array.length;
                const output = new Array(n);
                const count = new Array(10).fill(0);

                for (let i = 0; i < n; i++) {
                    const digit = Math.floor(this.array[i] / exp) % 10;
                    count[digit]++;
                    await this.highlightBars([i], 'comparing');
                    this.accesses++;
                    this.updateStats();
                    await this.sleep();
                    await this.unhighlightBars([i]);
                }

                for (let i = 1; i < 10; i++) {
                    count[i] += count[i - 1];
                }

                for (let i = n - 1; i >= 0; i--) {
                    const digit = Math.floor(this.array[i] / exp) % 10;
                    output[count[digit] - 1] = this.array[i];
                    count[digit]--;
                    await this.highlightBars([i], 'swapping');
                    await this.sleep();
                    await this.unhighlightBars([i]);
                }

                for (let i = 0; i < n; i++) {
                    this.array[i] = output[i];
                    await this.updateBar(i, this.array[i]);
                    await this.sleep();
                }
            }

            // BUCKET SORT
            async bucketSort() {
                const n = this.array.length;
                if (n <= 0) return;

                const max = Math.max(...this.array);
                const min = Math.min(...this.array);
                const bucketCount = Math.floor(Math.sqrt(n));
                const buckets = Array.from({ length: bucketCount }, () => []);

                for (let i = 0; i < n; i++) {
                    await this.highlightBars([i], 'comparing');
                    const bucketIndex = Math.floor(((this.array[i] - min) / (max - min + 1)) * bucketCount);
                    buckets[Math.min(bucketIndex, bucketCount - 1)].push(this.array[i]);
                    this.accesses++;
                    this.updateStats();
                    await this.sleep();
                    await this.unhighlightBars([i]);
                }

                let index = 0;
                for (let i = 0; i < bucketCount; i++) {
                    buckets[i].sort((a, b) => a - b);
                    for (let j = 0; j < buckets[i].length; j++) {
                        this.array[index] = buckets[i][j];
                        await this.updateBar(index, this.array[index]);
                        await this.sleep();
                        index++;
                    }
                }
            }

            // TIM SORT
            async timSort() {
                const RUN = 32;
                const n = this.array.length;

                for (let i = 0; i < n; i += RUN) {
                    await this.insertionSortForTim(i, Math.min(i + RUN - 1, n - 1));
                }

                for (let size = RUN; size < n; size = 2 * size) {
                    for (let start = 0; start < n; start += 2 * size) {
                        const mid = start + size - 1;
                        const end = Math.min(start + 2 * size - 1, n - 1);

                        if (mid < end) {
                            await this.merge(start, mid, end);
                        }
                    }
                }
            }

            async insertionSortForTim(left, right) {
                for (let i = left + 1; i <= right; i++) {
                    const key = this.array[i];
                    let j = i - 1;

                    await this.highlightBars([i], 'pivot');
                    await this.sleep();

                    while (j >= left && this.array[j] > key) {
                        this.comparisons++;
                        this.accesses++;
                        this.updateStats();

                        this.array[j + 1] = this.array[j];
                        await this.updateBar(j + 1, this.array[j + 1]);
                        await this.sleep();
                        j--;
                    }

                    this.array[j + 1] = key;
                    await this.updateBar(j + 1, key);
                    await this.unhighlightBars([i]);
                }
            }

            updateAlgorithmInfo() {
                const algorithm = this.algorithmSelect.value;
                const info = this.getAlgorithmInfo(algorithm);
                
                const html = `
                    <h3>${info.name}</h3>
                    <p class="description">${info.description}</p>
                    <div class="complexity-grid">
                        <div class="complexity-item">
                            <div class="complexity-label">Best Case</div>
                            <div class="complexity-value">${info.bestCase}</div>
                        </div>
                        <div class="complexity-item">
                            <div class="complexity-label">Average Case</div>
                            <div class="complexity-value">${info.averageCase}</div>
                        </div>
                        <div class="complexity-item">
                            <div class="complexity-label">Worst Case</div>
                            <div class="complexity-value">${info.worstCase}</div>
                        </div>
                        <div class="complexity-item">
                            <div class="complexity-label">Space Complexity</div>
                            <div class="complexity-value">${info.space}</div>
                        </div>
                        <div class="complexity-item">
                            <div class="complexity-label">Stable</div>
                            <div class="complexity-value">${info.stable ? 'Yes' : 'No'}</div>
                        </div>
                        <div class="complexity-item">
                            <div class="complexity-label">In-Place</div>
                            <div class="complexity-value">${info.inPlace ? 'Yes' : 'No'}</div>
                        </div>
                    </div>
                `;
                
                document.getElementById('algorithmInfo').innerHTML = html;
            }

            getAlgorithmInfo(algorithm) {
                const algorithms = {
                    bubble: {
                        name: 'Bubble Sort',
                        description: 'A simple comparison-based algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.',
                        bestCase: 'O(n)',
                        averageCase: 'O(n²)',
                        worstCase: 'O(n²)',
                        space: 'O(1)',
                        stable: true,
                        inPlace: true
                    },
                    insertion: {
                        name: 'Insertion Sort',
                        description: 'Builds the final sorted array one item at a time by inserting each element into its proper position. Efficient for small data sets and nearly sorted data.',
                        bestCase: 'O(n)',
                        averageCase: 'O(n²)',
                        worstCase: 'O(n²)',
                        space: 'O(1)',
                        stable: true,
                        inPlace: true
                    },
                    selection: {
                        name: 'Selection Sort',
                        description: 'Divides the input list into a sorted and unsorted region. It repeatedly selects the smallest element from the unsorted region and moves it to the end of the sorted region.',
                        bestCase: 'O(n²)',
                        averageCase: 'O(n²)',
                        worstCase: 'O(n²)',
                        space: 'O(1)',
                        stable: false,
                        inPlace: true
                    },
                    quick: {
                        name: 'Quick Sort',
                        description: 'A divide-and-conquer algorithm that selects a pivot element and partitions the array around it. Elements smaller than the pivot go left, larger go right. Recursively sorts the sub-arrays.',
                        bestCase: 'O(n log n)',
                        averageCase: 'O(n log n)',
                        worstCase: 'O(n²)',
                        space: 'O(log n)',
                        stable: false,
                        inPlace: true
                    },
                    merge: {
                        name: 'Merge Sort',
                        description: 'A divide-and-conquer algorithm that divides the array into two halves, recursively sorts them, and then merges the sorted halves. Guarantees O(n log n) performance.',
                        bestCase: 'O(n log n)',
                        averageCase: 'O(n log n)',
                        worstCase: 'O(n log n)',
                        space: 'O(n)',
                        stable: true,
                        inPlace: false
                    },
                    heap: {
                        name: 'Heap Sort',
                        description: 'Uses a binary heap data structure to sort elements. First builds a max heap, then repeatedly extracts the maximum element and rebuilds the heap with the remaining elements.',
                        bestCase: 'O(n log n)',
                        averageCase: 'O(n log n)',
                        worstCase: 'O(n log n)',
                        space: 'O(1)',
                        stable: false,
                        inPlace: true
                    },
                    counting: {
                        name: 'Counting Sort',
                        description: 'A non-comparison based algorithm that counts the number of objects with distinct key values. Uses this count to determine positions. Efficient when the range of input is not significantly greater than the number of elements.',
                        bestCase: 'O(n + k)',
                        averageCase: 'O(n + k)',
                        worstCase: 'O(n + k)',
                        space: 'O(k)',
                        stable: true,
                        inPlace: false
                    },
                    radix: {
                        name: 'Radix Sort',
                        description: 'A non-comparison based algorithm that sorts integers by processing individual digits. Processes digits from least significant to most significant, using counting sort as a subroutine.',
                        bestCase: 'O(nk)',
                        averageCase: 'O(nk)',
                        worstCase: 'O(nk)',
                        space: 'O(n + k)',
                        stable: true,
                        inPlace: false
                    },
                    bucket: {
                        name: 'Bucket Sort',
                        description: 'Distributes elements into buckets, sorts each bucket individually (often using another algorithm), and then concatenates the buckets. Works best when input is uniformly distributed.',
                        bestCase: 'O(n + k)',
                        averageCase: 'O(n + k)',
                        worstCase: 'O(n²)',
                        space: 'O(n + k)',
                        stable: true,
                        inPlace: false
                    },
                    tim: {
                        name: 'Tim Sort',
                        description: 'A hybrid stable sorting algorithm derived from merge sort and insertion sort. Divides data into small chunks (runs), sorts them using insertion sort, then merges using merge sort. Used in Python and Java.',
                        bestCase: 'O(n)',
                        averageCase: 'O(n log n)',
                        worstCase: 'O(n log n)',
                        space: 'O(n)',
                        stable: true,
                        inPlace: false
                    }
                };

                return algorithms[algorithm];
            }
        }

        // Initialize the visualizer
        const visualizer = new SortingVisualizer();
    </script>
</body>
</html>
